<!DOCTYPE html>
<html>
  <head>
    <title>Dan Maljovec's Homepage</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="Dan Maljovec Daniel Patrick Computer Science CS Graphics Gannon University Utah Erie GE Insight Technology ImmersiMap" />
	  <meta name="description" content="Dan Maljovec graduated from Gannon May 9, 2009 and is now a Graduate Student at the University of Utah in the School of Computing's Graphics and Visualization Track." />
    <!-- Styles -->
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.css">
	  <link rel="stylesheet" type="text/css" href="css/common.css" />
    <link rel="stylesheet" type="text/css" href="css/menu.css" />
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <!-- Scripts -->
    <script src="http://d3js.org/d3.v4.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <!-- <script src="numeric-1.2.6.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vectorious/5.5.0/vectorious.min.js" integrity="sha256-TnabZDLM9KzkhbPKOB2yFCU1Y65VzbwZt8PP6HaLv6M=" crossorigin="anonymous"></script>
    <script src="js/menu.js"></script>
    <!-- Common variables and functions used by all of the example plots -->
    <script type="text/javascript">
      var width = 300;          //Width of each plot
      var height = 300;         //Height of each plot
      var cellSize = 50;

      // The sample point set used by all of the static examples
      var numSamples = 12;            // Number of points to use
      var X = new Array(numSamples);  // The independent variable
      var Y = new Array(numSamples);  // The idependent variable
      var W = new Array(numSamples);  // The weights

      // The samples generated by the user
      var maxSamples = 20;          // The maximum number of points to add
      var Xtest = new Array();      // The independent variable
      var Ytest = new Array();      // The dependent variable
      var Wtest = new Array();      // The weights

      // User adjustable parameters for MLS
      var mlsScale = 0.05;          // Scale parameter for the fixed case
      var editScale = 1;            // Scale parameter for the interactive case

      //////////////////////////////////////////////////////////////////////////
      // Reusable Functions (should not depend on any information specifically
      // in this document)

      /** Function for performing ordinary least squares for a polynomial degree
       *  1 and includes fitting of the bias (y-intercept) term.
       *  @param {Array} X - the input space of the problem, currently, assumed
       *                     to be a 1-dimensional array of size N.
       *  @param {Array} Y - the output space of the problem, assumed to be
       *                     a 1-dimensional array of size N.
       *  @param {number} xmin - the minimum input value to fit
       *  @param {number} xmax - the maximum input value to fit
       *  @param {number} step - the step size between input values to fit. This
                                 together with xmin and xmax determines the size
                                 of the returned sampled array.
       *  @returns {Array} - will return an array of size 2*(xmax-xmin)/step
       *                     that contains sampled values of X and Y in the
       *                     following order: x0, y0, x1, y1, ..., xm, ym
       */
      function fitOLS(X, Y, xmin=0, xmax=width, step=1) {
        return fitWLS(X, Y, [], xmin, xmax, step);
      }

      /** Function for performing weighted least squares for a polynomial degree
       *  1 and includes fitting of the bias (y-intercept) term.
       * TODO: should detect whether input is one or two dimensional and handle
       *       each case appropriately. Currently, it assumes data is 1D
       *       internally wraps it to make it 2D Matrix. It should be
       *       straightforward to extend this by directly importing 2D Arrays.
       * TODO: should be able to handle multiple Y columns constructing a 2D
       *       Matrix for Y.
       *  @param {Array} X - the input space of the problem, currently, assumed
       *                     to be a 1-dimensional array of size N.
       *  @param {Array} Y - the output space of the problem, assumed to be
       *                     a 1-dimensional array of size N.
       *  @param {Array} W - the weights of the problem, assumed to be a
       *                     1-dimensional array of size N.
       *  @param {number} xmin - the minimum input value to fit
       *  @param {number} xmax - the maximum input value to fit
       *  @param {number} step - the step size between input values to fit. This
                                 together with xmin and xmax determines the size
                                 of the returned sampled array.
       *  @returns {Array} - will return an array of size 2*(xmax-xmin)/step
       *                     that contains sampled values of X and Y in the
       *                     following order: x0, y0, x1, y1, ..., xm, ym
       */
      function fitWLS(X, Y, W=[], xmin=0, xmax=width, step=1) {

        if (Y.length < 2) {
          return Array();
        }

        if (W.length == 0) {
          W = Vector.ones(Y.length).toArray();
        }

        var Xmat;   // X in matrix format
        var XmatT;  // The transpose of X
        var Ymat;   // Y in matrix format
        var Wmat;   // Y in matrix format
        var beta; // The final coefficients used for prediction

        // The row of ones allows fitting of the y-intercept (bias term),
        // otherwise the data is assumed to pass through the origin.
        XmatT = new Matrix([X, Vector.ones(X.length).toArray()]);
        Ymat = new Matrix([Y]).transpose();
        Xmat = XmatT.transpose();
        Wmat = Matrix.identity(W.length);

        // Note, the weights should be non-negative and there must be at
        // least two values that are larger than zero. If not, then the
        // solution will be degenerate.

        function sum(total, num) {
            return total + num;
        }

        var normalizationFactor = W.reduce(sum);
        for (var i = 0; i < W.length; i++) {
          Wmat.set(i, i, W[i]/normalizationFactor);
        }

        beta = new Vector(XmatT.multiply(Wmat).multiply(Xmat).inverse().multiply(XmatT.multiply(Wmat).multiply(Ymat)).toArray());

        var sampled = new Array(2*((xmax-xmin)/step));

        var idx = 0;
        for ( var i = xmin; i < xmax; i+=step) {
          Xi = new Vector([i, 1]);
          sampled[2*idx] = i;
          sampled[2*idx+1] = beta.dot(Xi);
          idx++;
        }
        return sampled;
      }


      /** A Gaussian weighting function that is everywhere non-negative,
       *  reaches a maximum value at s=0, and is symmetric about s=0.
       *  @param {number} s - the location to query the Gaussian.
       *  @param {number} scale - the scale/sigma parameter to use for the
       *                          Gaussian. Smaller values represent a steeper
       *                          shape.
       *  @returns {number} - The evaluation of the Gaussian function at s
       */
      function theta(s, scale = 1) {
        // return Math.exp(-Math.pow(s,2));
        return 1./Math.sqrt(scale * Math.PI) * Math.exp(-Math.pow(s,2) / scale);
      }

      /** Function for performing weighted least squares for a polynomial degree
       *  1 and includes fitting of the bias (y-intercept) term.
       * TODO: should detect whether input is one or two dimensional and handle
       *       each case appropriately. Currently, it assumes data is 1D
       *       internally wraps it to make it 2D Matrix. It should be
       *       straightforward to extend this by directly importing 2D Arrays.
       * TODO: should be able to handle multiple Y columns constructing a 2D
       *       Matrix for Y.
       *  @param {Array} X - the input space of the problem, currently, assumed
       *                     to be a 1-dimensional array of size N.
       *  @param {Array} Y - the output space of the problem, assumed to be
       *                     a 1-dimensional array of size N.
       *  @param {Array} W - the weights of the problem, assumed to be a
       *                     1-dimensional array of size N.
       *  @param {number} xmin - the minimum input value to fit
       *  @param {number} xmax - the maximum input value to fit
       *  @param {number} step - the step size between input values to fit. This
                                 together with xmin and xmax determines the size
                                 of the returned sampled array.
       *  @returns {Array} - will return an array of size 2*(xmax-xmin)/step
       *                     that contains sampled values of X and Y in the
       *                     following order: x0, y0, x1, y1, ..., xm, ym
       */
      function fitMLS(X, Y, scale=1, xmin=0, xmax=width, step=1) {

        if (Y.length < 2) {
          return Array();
        }

        var idx = 0;
        for ( var i = xmin; i < xmax; i+=step) {
          var W = new Array(X.length);
          for (var j in X) {
            var delta = new Vector([i]).subtract(new Vector([X[j]]));
            // Let's scale the magnitude of the vector by the width of our
            // svg in order to bring this distance function into an
            // appropriate scale
            W[j] = theta(delta.magnitude()/width, scale);
          }
          sampled[2*idx] = i;
          sampled[2*idx+1] = fitWLS(X, Y, W, i, i+1)[1];
          idx++;
        }
        return sampled;
      }

      /** Function for drawing a set of points and optional weights onto an svg
       * instance.
       *  @param {d3.selection} svg - the svg tag on which we will draw.
       *  @param {Array} X - the input space of the problem, currently, assumed
       *                     to be a 1-dimensional array of size N.
       *  @param {Array} Y - the output space of the problem, assumed to be
       *                     a 1-dimensional array of size N.
       *  @param {Array} W - the weights of the problem, assumed to be a
       *                     1-dimensional array of size N, if it is smaller
       *                     than N, equal weights of 1 are assumed.
       */
      function drawPoints(svg, X, Y, W = []) {
        for (var i = 0; i < maxSamples; i++) {
          var point = svg.select("#point_"+i.toString());
          if (point.empty()) {
            point = svg.append("circle")
                      .attr("class", "point")
                      .attr("id", "point_"+i.toString())
          }
          point.attr("cx", 0)
              .attr("cy", 0)
              .attr("r", 0);
        }

        for (var i = 0; i < X.length; i++)
        {
          var x = X[i];
          var y = Y[i];
          var w;

          if (W.length < X.length) {
            w = 1;
          }
          else {
             w = W[i];
          }

          var point = svg.select("#point_"+i.toString());

          if (point.empty()) {
            point = svg.append("circle")
                      .attr("class", "point")
                      .attr("id", "point_"+i.toString())
          }

          point.attr("cx", x)
              .attr("cy", y)
              .attr("r", 5*Math.sqrt(w));
        }
      }

      /** Function for drawing a solved regression curve.
       *  @param {d3.selection} svg - the svg tag on which we will draw.
       *  @param {Array} sampled - An array of that contains sampled values of
       *                           X (independent) and Y (dependent) in the
       *                           following order: x0, y0, x1, y1, ..., xm, ym
       *  @param {Array} Y - the output space of the problem, assumed to be
       *                     a 1-dimensional array of size N.
       *  @returns {d3.selection} - The polyline instance which has just been
       *                            drawn
       */
      function drawCurve(svg, sampled) {
        var N = sampled.length / 2;

        var polyLine = d3.path();
        if (sampled.length > 1) {
          polyLine.moveTo(sampled[0], sampled[1]);
        }

        for ( var i = 0; i < N; i++) {
          polyLine.lineTo(sampled[2*i], sampled[2*i+1]);
        }

        return svg.select('.curves').append("path")
                .attr("class", "regression")
                .style("stroke-width", "4")
                .style("fill", "none")
                .attr("d", polyLine.toString());
      }

      /** Function for generating an svg instance with some defaults with a
       *  consistent look-and-feel
       *  @param {string} id - the id of the generated svg tag.
       *  @param {number} width - The width of the svg tag
       *  @param {number} height - The height of the svg tag
       *  @param {number} cellSize - The spacing of the background grid cells.
       *                             They will be uniform in the horizontal and
       *                             vertical directions.
       *  @returns {d3.selection} - The svg instance which has been generated
       */
      function makeSVGGraph(id, width, height, cellSize) {
        var svgGraph = d3.select("body").select("#site-body").append("svg")
                            .attr("class", "svgGraph")
                            .attr("id", id)
                            .attr("width", width)
                            .attr("height", height)
                            .style("display", "block")
                            .style("margin", "auto")
                            .style("border", "1px solid black");
        //Add the curves to this g element to ensure they are drawn behind the
        // points and do not adversely affect the highlighting of points.
        svgGraph.append('g').attr('class', 'curves');
        drawGrid(svgGraph, cellSize);
        return svgGraph;
      }

      /** Function for drawing a background grid on a target svg tag.
       *  @param {d3.selection} svg - the svg tag on which we will draw.
       *  @param {number} cellSize - The spacing of the background grid cells
       *                             They will be uniform in the horizontal and
       *                             vertical directions.
       */
      function drawGrid(svg, cellSize) {
          svg.selectAll('.grid').remove();
          var width = svg.node().getBoundingClientRect().width;
          var height = svg.node().getBoundingClientRect().height;

          svg.append("path")
            .attr("class", "grid")
            .attr("d", d3.range(cellSize, width, cellSize)
            .map(function(x) { return "M" + Math.round(x) + ",0V" + height; })
            .join("")
            + d3.range(cellSize, height, cellSize)
                .map(function(y) { return "M0," + Math.round(y) + "H" + width; })
                .join(""));
      }

      //////////////////////////////////////////////////////////////////////////

      // Functions specific to the data of this page

      /** Function for initializing pre-defined static data for X, Y, and W.
       */
      function InitializeStaticData() {
        //Fixed points ensure a good test case
         X[0] = 50;     W[0] = 6;
         X[1] = 70;     W[1] = 2;
         X[2] = 90;     W[2] = 6;
         X[3] = 110;    W[3] = 5;
         X[4] = 130;    W[4] = 3;
         X[5] = 150;    W[5] = 1;
         X[6] = 170;    W[6] = 1;
         X[7] = 190;    W[7] = 1;
         X[8] = 210;    W[8] = 1;
         X[9] = 230;    W[9] = 1;
        X[10] = 250;    W[10] = 1;
        X[11] = 250;    W[11] = 8;

        for (var i = 0; i < X.length; i++) {
          // Add some random perturbation
          Y[i] = 250 - Math.abs(X[i] + 25*(2*Math.random()-1) - 200);
        }
        Y[11] = 50;
      }

      /** Callback function executed on mouse move events for specifically
       *  handling the "drag" event that will resize/reweight an existing data
       *  point.
       */
      function editMouseMove() {
        var modifiedObject = d3.select('.active');

        if (!modifiedObject.empty())
        {
          var mousePoint = d3.mouse(modifiedObject.node().parentNode);
          var mx = mousePoint[0];
          var my = mousePoint[1];
          var objectId = modifiedObject.attr('id');

          if (objectId && objectId.startsWith('point')) {
            var idx = parseInt(modifiedObject.attr('id').split('_')[1]);
            var px = modifiedObject.attr('cx')
            var py = modifiedObject.attr('cy');
            var d = Math.sqrt(Math.pow(mx-px,2) + Math.pow(my-py,2));
            // var d = (mx-px);
            Wtest[idx] = Math.min(Math.max(d/10,1), 10);
            updatePlots();
          }
        }
      }

      /** Callback function executed on mouse down events for generating new
       *  points or selecting existing points marking them as members of the
       *  "active" class. Also, triggers the window to listen for mouse
       *  movements since we are currently in "drag" mode after this fires.
       */
      function editMouseDown() {
        d3.event.preventDefault(); // disable default text dragging
        var mouseButton = d3.event.button;

        var objectUnderMouse = d3.select(document.elementFromPoint(d3.event.x, d3.event.y));

        var mousePoint = d3.mouse(this);
        var x = mousePoint[0];
        var y = mousePoint[1];
        if (mouseButton == 2 && objectUnderMouse.classed('point')) {
          var idx = parseInt(objectUnderMouse.attr('id').split('_')[1]);
          Xtest.splice(idx,1);
          Ytest.splice(idx,1);
          Wtest.splice(idx,1);
        }
        else if ( mouseButton == 0  && !objectUnderMouse.classed('point')
                 && Xtest.length < maxSamples ) {
          Xtest.push(x);
          Ytest.push(y);
          Wtest.push(1);
        }

        updateDynamicExample();

        // Now the point should exist either way, so make sure it is active,
        // This allows for initially setting the weight
        var objectUnderMouse = d3.select(document.elementFromPoint(d3.event.x, d3.event.y));
        objectUnderMouse.classed('active', true);

        if (mouseButton == 0) {
          var w = d3.select(window)
                  .on("mousemove", editMouseMove)
                  .on("mouseup", editMouseUp);
        }
        else {
          var w = d3.select(window)
                  .on("mousemove", null)
                  .on("mouseup", null);
        }
      }

      /** Callback function executed on mouse up events for removing all
       *  elements from the "active" class and disabling the need for the
       *  window to listen for mouse movements.
       */
      function editMouseUp() {
        var objectUnderMouse = d3.select('.active');
        objectUnderMouse.classed('active', false);

        var w = d3.select(window)
                .on("mousemove", null)
                .on("mouseup", null);
      }

      /** Callback function executed on right mouse click events for removing
       *  a point from the data set.
       */
      function editRightClick() {
        d3.event.preventDefault();
      }

      /** Callback function executed when the user updates the fixed mls example
       *  slider. This will update the text onscreen and redraw all of the plots
       *  too.
       *  TODO: This only needs to update one plot.
       *  @param {string} - a string representation of the updated scale value
       */
      function updateMLSSigma(newValue) {
        mlsScale = parseFloat(newValue);
        document.getElementById("mlsSigma").innerHTML = mlsScale.toFixed(2);
        updateStaticExamples();
      }

      /** Callback function executed when the user updates the interactive
       *  example slider. This will update the text onscreen and redraw the
       *  interactive plot.
       *  @param {string} - a string representation of the updated scale value
       */
      function updateEditSigma(newValue) {
        editScale = parseFloat(newValue);
        document.getElementById("editSigma").innerHTML = editScale.toFixed(2);
        updateDynamicExample();
      }


      /** Function for redrawing all of the examples
       */
      function updatePlots() {
        updateDynamicExample();
        updateStaticExamples();
      }

      /** Function for redrawing the interactive example
       */
      function updateDynamicExample() {
        var editSVG = d3.select("#editSVG");
        drawPoints(editSVG, Xtest, Ytest, Wtest);
        editSVG.selectAll('.regression').remove();

        sampled = fitOLS(Xtest, Ytest);
        curve = drawCurve(editSVG, sampled);
        curve.classed('ols', true);

        sampled = fitWLS(Xtest, Ytest, Wtest);
        curve = drawCurve(editSVG, sampled);
        curve.classed('wls', true);

        sampled = fitMLS(Xtest, Ytest, editScale);
        curve = drawCurve(editSVG, sampled);
        curve.classed('mls', true);
      }

      /** Function for redrawing the static examples
       */
      function updateStaticExamples() {
        var olsSVG = d3.select("#olsSVG");
        drawPoints(olsSVG, X, Y);
        sampled = fitOLS(X, Y);
        olsSVG.selectAll('.regression').remove();
        curve = drawCurve(olsSVG, sampled);
        curve.classed('ols', true);

        var wlsSVG = d3.select("#wlsSVG");
        drawPoints(wlsSVG, X, Y, W);
        sampled = fitWLS(X, Y, W);
        wlsSVG.selectAll('.regression').remove();
        curve = drawCurve(wlsSVG, sampled);
        curve.classed('wls', true);

        var mlsSVG = d3.select("#mlsSVG");
        drawPoints(mlsSVG, X, Y);
        sampled = fitMLS(X, Y, mlsScale);
        mlsSVG.selectAll('.regression').remove();
        curve = drawCurve(mlsSVG, sampled);
        curve.classed('mls', true);
      }

    </script>
    <style>
      /**********************************************/
      /* SVG Elements */
      .grid {
        stroke: #000;
        stroke-opacity: .15;
        shape-rendering: crispEdges;
      }

      .point {
        fill: #000;
        stroke-width: 0px;
      }

      .active {
        fill: #c33;
      }
      /**********************************************/
      /**********************************************/
      /* HTML Elements */
      .uiElement {
        margin: auto;
        text-align: center;
        padding-top: 10px;
        padding-bottom: 10px;
      }

      .emph {
        font-weight: bold;
        stroke-width: 8;
      }

      /**********************************************/
      /* Color-coding each type of least squares */
      .ols {
        /* Yellow */
        color: #7c7c16;
        stroke: #7c7c16;
        /* Teal */
        /*color: #1b9e77;*/
        /*stroke: #1b9e77;*/

      }

      a.ols:hover {
        /* Dark Yellow */
        color: #3b3b0a;
        /* Dark Teal */
        /*color: #1b9e77;*/
      }

      .wls {
        /* Green */
        color: #006400;
        stroke: #006400;
        stroke-dasharray: 5, 5;
        /* Orange */
        /*color: #d95f02;*/
        /*stroke: #d95f02;*/
      }

      a.wls:hover {
        /* Dark Green */
        color: #001800;
        /* Dark Orange */
        /*color: #8d3e01;*/
      }

      .mls {
        /* Blue */
        color: #377eb8;
        stroke: #69a3d2;
        stroke-dasharray: 10, 5;
        /* Purple */
        /*color: #7570b3;*/
        /*stroke: #7570b3;*/
      }

      a.mls:hover {
        /* Dark Blue */
        color: #25567d;
        /* Dark Purple */
        /*color: #7570b3;*/
      }
      /**********************************************/
      /**********************************************/
      /* Don't let the headers be "highlightable" */
      h2  a.ols:hover {
        color: #7c7c16;
      }
      h2  a.wls:hover {
        color: #006400;
      }
      h2  a.mls:hover {
        color: #377eb8;
      }
      h1 a, a:hover {
        color: #333;
      }
      /**********************************************/

    </style>
  </head>

  <body>
    <div id="site-wrapper">
      <!-- <a href="#" class="toggle-nav btn" id="toggleBtn"><i class="fa fa-bars"></i></a> -->
      <div id="site-canvas">
        <h1 id="site-title">Dan Maljovec</h1>
        <div id="site-menu">
          <ul>
            <li><img alt='maljovec' class='avatar' src="https://avatars3.githubusercontent.com/u/8671026?v=3&s=460"></li>
            <li><a href="#"><i class="toggle-nav fa fa-chevron-right fa-fw" id="toggleMenu"></i></a></li>
            <li><a href="index.html">Home <i class="fa fa-home fa-fw"></i></a></li>
            <li><a href="cv.html">CV <i class="fa fa-file-text fa-fw"></i></a></li>
            <li><a href="pubs.html">Papers <i class="fa fa-files-o fa-fw"></i></a></li>
            <li><a href="academia.html">Academia <i class="fa fa-graduation-cap fa-fw"></i></a></li>
           <!-- <li><a href="projects.html">Projects <i class="fa fa-cogs fa-fw"></i></a></li> -->
            <li><a href="experiment.html">Experimental <i class="fa fa-flask fa-fw"></i></a></li>
          </ul>
        </div>
        <div id="site-body">
        <h1 class="content">Fixed Examples</h1>
        <p class='content'>
          The goal in this exercise will be to fit a scalar dependent value, y,
          to a scalar independent value, x.
          In these visual examples, we will take the horizontal dimension to be
          our independent value, x, and the vertical dimension to be a our
          dependent variable, y. Let us begin by exploring a pre-defined fixed
          set of points (Note, there is some random noise in the y value, so
          reloads of this page may look different).
        </p>
        <p class='content'>
          We first fit a noisy parabola using <a href='#ols' class='emph ols'>Ordinary
          Least Squares</a>.
          Next, we will apply a set of pre-defined, variable weights to the data
          and fit it using <a href='#wls' class='emph wls'>Weighted Least Squares</a>.
          Lastly, we will take this same set of points and allow the weights to
          be defined locally to the query location using a Gaussian weighting
          function in a process known as
          <a href='#mls' class='emph mls'>Moving Least Squares</a>.
        </p>
        <p class='content'>
          After this experiment, I offer an <a href="#interactive">interactive example</a>
          that allows
          you to specify your own training data set and explore all three fits
          on a single graph.
        </p>
        <!-- The Fixed Ordinary Least Squares Case -->
        <h2 class="content"><a name='ols' class='ols'>Ordinary Least Squares</a></h2>
        <p class='content'>
          For the ordinary least squares case, all of the data has the same
          weight.
          Thus, the outlier tends to pull the right side of the fit
          upward, but its effect is limited since there is more data showing
          a downward trend.
          Note, that without weighting, the majority trend will prevail.
          That is, since there are more points on the first half of the dataset
          we report a downward slope on our fit.
        </p>
        <script>
          var olsSVG = makeSVGGraph('olsSVG', width, height, cellSize);
        </script>

        <!-- The Fixed Weighted Least Squares Case -->
        <h2 name='wls' class="content"><a name='wls' class='wls'>Weighted Least Squares</a></h2>
        <p class='content'>
          Now that the weights are accounted for, we can see that the large
          weight of the outlier is actually able to change the sign of the
          sloped of the fitted line.
          In this example, we are still restricted to a linear fit as we are
          still solving a global problem with one set of coefficients.
        </p>
        <script>
          var wlsSVG = makeSVGGraph('wlsSVG', width, height, cellSize);
        </script>

        <!-- The Fixed Moving Least Squares Case -->
        <h2 class="content"><a name='mls' class='mls'>Moving Least Squares</a></h2>
        <p class='content'>
          Note, in this case we can actually fit a non-linear curve to the data
          since we solve a local linear problem at each query location.
          Because these local linear problems depend on a weighting function,
          <span style='font-weight: bold;'>&theta;</span>(
          <span style='font-weight: bold;'>x&#772;</span>,&sigma;), that varies
          smoothly as we smoothly vary
          <span style='font-weight: bold;'>x&#772;</span>, we can ensure a
          C<sub>1</sub> non-linear surface.
          The intuition here is we are smoothly blending neighboring local
          linear models.
        </p>
        <p class='content'>
          Also, note that as &sigma; grows, we approach the ordinary least
          squares solution, since we are in essence flattening our Gaussian
          function such that all of the weights approach 1 (that is, points
          farther from <span style='font-weight: bold;'>x&#772;</span> have
          weights that become indistinguishable to points close to
          <span style='font-weight: bold;'>x&#772;</span>).
        </p>

        <p class="body uiElement">
          &sigma;:
          <input type="range" id='sigmaMLSInput'
                 min="0.05" max="2" value="0.05" step="0.05"
                 oninput="updateMLSSigma(this.value)" />
          <span id="mlsSigma"></span>
        </p>
        <script>
            var mlsSVG = makeSVGGraph('mlsSVG', width, height, cellSize);
        </script>

        <!-- The User-editable Case -->
        <h1 class="content"><a name="interactive">Custom Example</a></h1>
        <p class='content'>
          Now, you can build your own point set and play with the weights and
          scale parameter to see how these things work on a 1D case (note, the
          vertical dimension is the dependent variable and the horizontal
          dimension represents the independent variable).
        </p>

        <p class='content'>
          For more advanced manipulation, you can open the source code and
          modify the theta function to use a different weighting function.
          You can even extend the least squares input array, X, to include
          higher order values such as x<sup>2</sup> and x<sup>3</sup> to try
          fitting nonlinear functions, or you could even fit polar coordinates,
          given a radius and angle, compute an x and a y.
          In this last case, you would be fitting multiple dependent variables.
        </p>

        <p class='content'>
          I have not yet attempted these myself, but I tried to make the "fit"
          functions generic enough to handle multidimensional inputs.
          Multidimensional outputs may be a bit more work.
        </p>

        <h3 class="content">Instructions</h3>
        <p class='content'><span class='emph'>Left click</span> on the graph below to add up to
          <span class="emph" id="maxSamples"></span> training points for
          fitting.
          <span class='emph'>Left click-and-dragging</span> will adjust the weight of a training point.
          The size of the point will reflect its relative weight.
          You can delete existing data points by <span class='emph'>right clicking</span> on the point
          you wish to remove.
          Also, you can adjust the scale parameter,
          <span class="emph">&sigma;</span>, which determines how quickly the
          weighting function falls off for the moving least squares solution.
        </p>
        <h3 class="content" style='margin: auto; text-align: center;'>Key</h3>
        <table class="content uiElement">
          <tr>
            <td><span class="emph ols">Ordinary Least Squares</span></td>
            <td><svg width="50" height="10"><line class='emph ols' x1="10" y1="0" x2="40", y2="0"/></svg></td>
          </tr>
          <tr>
            <td><span class="emph wls">Weighted Least Squares</td>
            <td><svg width="50" height="10"><line class='emph wls' x1="10" y1="0" x2="40", y2="0"/></svg></td>
          </tr>
          <tr>
            <td><span class="emph mls">Moving Least Squares</td>
            <td><svg width="50" height="10"><line class='emph mls' x1="10" y1="0" x2="40", y2="0"/></svg></td>
          </tr>
        </table>
        <p class="body uiElement">
          &sigma;:
          <input type="range" id='sigmaEditInput'
                 min="0.05" max="2" value="1" step="0.05"
                 oninput="updateEditSigma(this.value)" />
          <span id="editSigma"></span>
        </p>
        <script>
          document.getElementById('maxSamples').textContent = maxSamples.toString();

          var editSVG = makeSVGGraph('editSVG', width, height, cellSize);

          // Allow for the user to interactively adjust points on this graph
          editSVG.on("mousedown", editMouseDown)
               .on("mouseup", editMouseUp)
               .on("mousemove", editMouseMove)
               .on("contextmenu", editRightClick);
        </script>

        <script>
          // Now that everyhing is setup, run it!
          InitializeStaticData();
          document.getElementById("editSigma").innerHTML = editScale;
          document.getElementById("mlsSigma").innerHTML = mlsScale;
          updatePlots();
        </script>
        </div>
      </div>
    </div>
  </body>
</html>
